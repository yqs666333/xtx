<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>TypeScript 基础 | 小兔鲜儿PC前台-开发文档</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/vue3-ts-erabbit-client-pc-document/public/hero.png">
    <meta name="description" content="小兔鲜儿PC前台-开发文档">
    <link rel="preload" href="/vue3-ts-erabbit-client-pc-document/assets/css/0.styles.03557c56.css" as="style"><link rel="preload" href="/vue3-ts-erabbit-client-pc-document/assets/js/app.37883b6e.js" as="script"><link rel="preload" href="/vue3-ts-erabbit-client-pc-document/assets/js/2.6206effc.js" as="script"><link rel="preload" href="/vue3-ts-erabbit-client-pc-document/assets/js/3.30ca6af5.js" as="script"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/10.9d62676c.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/11.0450e17c.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/12.20ad36f2.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/13.1d258475.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/14.9ffdd9a0.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/15.fd700b2c.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/16.1ead774b.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/17.db1b9830.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/18.729f4832.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/19.69ab7bd4.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/20.586c4c11.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/21.f402cea7.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/22.223b671f.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/23.d5bf69df.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/24.8dc79d49.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/25.a1c7fe92.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/4.c31de7f7.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/5.eade28ba.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/6.381cb28d.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/7.ce4fa56f.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/8.f1e3fba3.js"><link rel="prefetch" href="/vue3-ts-erabbit-client-pc-document/assets/js/9.f2d2558a.js">
    <link rel="stylesheet" href="/vue3-ts-erabbit-client-pc-document/assets/css/0.styles.03557c56.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/vue3-ts-erabbit-client-pc-document/" class="router-link-active home-link"><img src="/vue3-ts-erabbit-client-pc-document/hero.png" alt="小兔鲜儿PC前台-开发文档" class="logo"> <span class="site-name">小兔鲜儿PC前台-开发文档</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html" aria-current="page" class="router-link-exact-active router-link-active">
          TS基础
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/vue3-ts-erabbit-client-pc-document/vite/vite.html">
          Vite基础
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          Vue3基础
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/vue3-ts-erabbit-client-pc-document/pinia/pinia.html">
          Pinia基础
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          功能模块📂
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/vue3-ts-erabbit-client-pc-document/rabbit-shop/10-end.html">
          项目总结
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/vue3-ts-erabbit-client-pc-document/vscode/vscode.html">
          VsCode配置
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <a href="https://github.com/git@git.itcast.cn:sujiehao/erabbit-client-pc-vue3-ts-pinia.git" target="_blank" rel="noopener noreferrer" class="repo-link"><i aria-label="icon: Gitlab" class="anticon anticon-Gitlab"><!----></i></a></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript 基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#概述" title="概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#官方文档" title="官方文档" class="sidebar-link">官方文档</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#特点" title="特点" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#ts-与-js-的对比" title="TS 与 JS 的对比" class="sidebar-link">TS 与 JS 的对比</a></li></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#初体验" title="初体验" class="sidebar-link">初体验</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#说明" title="说明" class="sidebar-link">说明</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#步骤" title="步骤" class="sidebar-link">步骤</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#编译原理" title="编译原理" class="sidebar-link">编译原理</a></li></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#类型" title="类型" class="sidebar-link">类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#常用类型" title="常用类型" class="sidebar-link">常用类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#数组类型" title="数组类型" class="sidebar-link">数组类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#类型别名" title="类型别名" class="sidebar-link">类型别名</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#函数类型" title="函数类型" class="sidebar-link">函数类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#对象类型-2" title="对象类型" class="sidebar-link">对象类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#接口" title="接口" class="sidebar-link">接口</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#元组" title="元组" class="sidebar-link">元组</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#类型推断和断言" title="类型推断和断言" class="sidebar-link">类型推断和断言</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#字面量类型" title="字面量类型" class="sidebar-link">字面量类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#枚举类型" title="枚举类型" class="sidebar-link">枚举类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#👎any-类型" title="👎Any 类型" class="sidebar-link">👎Any 类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#其它-2" title="其它" class="sidebar-link">其它</a></li></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#高级类型" title="高级类型" class="sidebar-link">高级类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#交叉类型" title="交叉类型" class="sidebar-link">交叉类型</a></li></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#泛型" title="泛型" class="sidebar-link">泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#概念" title="概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#创建泛型函数" title="创建泛型函数" class="sidebar-link">创建泛型函数</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#调用泛型函数" title="调用泛型函数" class="sidebar-link">调用泛型函数</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#简化调用泛型函数" title="简化调用泛型函数" class="sidebar-link">简化调用泛型函数</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#泛型约束" title="泛型约束" class="sidebar-link">泛型约束</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#泛型接口" title="泛型接口" class="sidebar-link">泛型接口</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#泛型工具类型" title="泛型工具类型" class="sidebar-link">泛型工具类型</a></li></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#索引签名类型" title="索引签名类型" class="sidebar-link">索引签名类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#映射类型" title="映射类型" class="sidebar-link">映射类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#类型声明文件" title="类型声明文件" class="sidebar-link">类型声明文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#概述-3" title="概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#ts-中的两种文件类型" title="TS 中的两种文件类型" class="sidebar-link">TS 中的两种文件类型</a></li><li class="sidebar-sub-header"><a href="/vue3-ts-erabbit-client-pc-document/typescript/typescript.html#类型声明文件的使用说明" title="类型声明文件的使用说明" class="sidebar-link">类型声明文件的使用说明</a></li></ul></li></ul></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="typescript-基础"><a href="#typescript-基础" class="header-anchor">#</a> TypeScript 基础</h1> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/ts-logo.a4a6165d.svg" alt="img"></p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <h3 id="官方文档"><a href="#官方文档" class="header-anchor">#</a> 官方文档</h3> <blockquote><p>官方网址：<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">⚓https://www.typescriptlang.org/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>中文网址：<a href="https://www.tslang.cn/" target="_blank" rel="noopener noreferrer">⚓https://www.tslang.cn/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <ul><li>TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）。</li> <li>TypeScript = Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）。</li> <li>TypeScript 是微软开发的开源编程语言，可以在任何运行 JavaScript 的地方运行。</li></ul> <h3 id="ts-与-js-的对比"><a href="#ts-与-js-的对比" class="header-anchor">#</a> TS 与 JS 的对比</h3> <ol><li><p>更早（写代码的同时）发现错误，<code>减少找 Bug、改 Bug 时间</code>，提升开发效率。</p></li> <li><p>程序中任何位置的代码都有<code>代码提示</code>，随时随地的安全感，增强了开发体验。</p></li> <li><p>强大的<code>类型系统</code>提升了代码的可维护性，使得<code>重构代码更加容易</code>。</p></li> <li><p>支持<code>最新的 ECMAScript 语法</code>，优先体验最新的语法，让你走在前端技术的最前沿。</p></li> <li><p>TS<code>类型推断</code>机制，不需要在代码中的<code>每个地方都显示标注类型</code>，让你在享受优势的同时，尽量降低了成本。</p></li></ol> <p>除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端</p> <p>项目的首先编程语言。</p> <h2 id="初体验"><a href="#初体验" class="header-anchor">#</a> 初体验</h2> <h3 id="说明"><a href="#说明" class="header-anchor">#</a> 说明</h3> <p>浏览器和 <code>node</code> 环境中，并不能直接支持运行<code>.ts</code>的代码，我们必须借助于<code>typescript</code>这个全局包把<code>.ts</code>代码转成<code>.js</code>代码才能在node环境和浏览器环境中运行</p> <h3 id="步骤"><a href="#步骤" class="header-anchor">#</a> 步骤</h3> <ol><li><p>安装全局包 <code>npm i typescript -g</code></p></li> <li><p>在项目目录中创建<code>index.ts</code>，以<code>.ts</code>结尾的文件，代码如下</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'张三'</span>
<span class="token keyword">let</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，age is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>把终端切换到<code>index.ts</code>所在的目录，运行<code>tsc index.ts</code>把<code>ts</code>代码编译成<code>js</code>代码</p></li> <li><p>把生成好的js代码，在node中运行或是在浏览器端环境中运行即可</p></li></ol> <h3 id="编译原理"><a href="#编译原理" class="header-anchor">#</a> 编译原理</h3> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/tsc.ba55aed7.png" alt="tsc"></p> <h2 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h2> <h3 id="常用类型"><a href="#常用类型" class="header-anchor">#</a> 常用类型</h3> <h4 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h4> <p>可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型。</p> <p>1.JS 已有类型</p> <p>​	原始类型：number/string/boolean/null/undefined/symbol。</p> <p>​	对象类型：object（包括，数组、对象、函数等对象）。</p> <p>2.TS 新增类型</p> <p>​	联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any 等。</p> <h4 id="原始类型"><a href="#原始类型" class="header-anchor">#</a> 原始类型</h4> <p>number/string/boolean/null/undefined/symbol。</p> <p>特点：简单。这些类型，完全按照 JS 中类型的名称来书写。</p> <p>例子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'张三'</span>
<span class="token keyword">let</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span>
<span class="token keyword">let</span> isLoading<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// ...</span>
</code></pre></div><h4 id="对象类型"><a href="#对象类型" class="header-anchor">#</a> 对象类型</h4> <p>对象类型：object（包括，数组、对象、函数等对象）。</p> <p>特点：对象类型，在 TS 中更加细化，<strong>每个具体的对象都有自己的类型语法</strong>。</p> <h3 id="数组类型"><a href="#数组类型" class="header-anchor">#</a> 数组类型</h3> <p><code>数组类型</code>的两种写法：（<strong>推荐使用</strong> <strong>number[]</strong> <strong>写法</strong>）</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> numbers<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> strings<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span>
</code></pre></div><p>需求：数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写？</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> arr<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span>
</code></pre></div><p>解释：<code>|</code> （竖线）在 TS 中叫做<code>联合类型</code>（由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种）。</p> <p>注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（||）混淆了。</p> <h3 id="类型别名"><a href="#类型别名" class="header-anchor">#</a> 类型别名</h3> <p><code>类型别名</code>（自定义类型）：为任意类型起别名。</p> <p>使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，<code>简化该类型的使用</code>。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/type1.bfcde653.png" alt="type1"></p> <p>解释：</p> <ol><li><p>使用 <code>type</code> 关键字来创建类型别名。</p></li> <li><p>类型别名（比如，此处的 CustomArray），可以是任意合法的变量名称。</p></li> <li><p>创建类型别名后，直接<code>使用该类型别名作为变量的类型注解</code>即可。</p></li></ol> <h3 id="函数类型"><a href="#函数类型" class="header-anchor">#</a> 函数类型</h3> <p>函数的类型实际上指的是：函数<code>参数</code>和<code>返回值</code>的类型。</p> <p>为函数指定类型的两种方式：1 单独指定参数、返回值的类型 2 同时指定参数、返回值的类型。</p> <ol><li>单独指定参数、返回值的类型：</li></ol> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/function1.846fef23.png" alt="function1"></p> <ol start="2"><li>同时指定参数、返回值的类型：</li></ol> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/function2.2ed70f4a.png" alt="function2"></p> <p>如果函数没有返回值，那么，函数返回值类型为：void。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/function3.22a97fa3.png" alt="function3"></p> <p>使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到<code>可选参数</code>了。</p> <p>比如，数组的 slice 方法，可以 slice() 也可以 slice(1) 还可以 slice(1, 3)。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/function4.e044a4c4.png" alt="function4"></p> <h3 id="对象类型-2"><a href="#对象类型-2" class="header-anchor">#</a> 对象类型</h3> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/object1.27b0cf70.png" alt="object1"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/object2.b0db7b49.png" alt="object2"></p> <h3 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h3> <p>当一个对象类型被多次使用时，一般会使用<code>接口（interface）</code>来描述对象的类型，达到<code>复用</code>的目的。</p> <p>其实它是对对象类型的一个简化。</p> <p>解释：</p> <ol><li><p>使用 <code>interface</code> 关键字来声明接口。</p></li> <li><p>接口名称（比如，此处的 IPerson），可以是任意合法的变量名称。</p></li> <li><p>声明接口后，直接<code>使用接口名称作为变量的类型</code>。</p></li> <li><p>因为每一行只有一个属性类型，因此，属性类型后没有 ;（分号）。</p></li></ol> <p>语法：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span>
    <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
    
<span class="token keyword">let</span> person<span class="token operator">:</span> IPerson <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
    <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接口（interface）和类型别名（type）的对比</p> <ul><li><p>相同点：都可以给对象指定类型。</p></li> <li><p>不同点：</p> <p>​	 接口，只能为对象指定类型。</p> <p>​	 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名。</p></li></ul> <p>比较语法：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// 接口语法</span>
<span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span>
    <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
   
<span class="token comment">// 类型别名语法</span>
<span class="token keyword">type</span> <span class="token class-name">IPerson</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span>
    <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
   
<span class="token comment">// 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名。</span>
<span class="token keyword">type</span> <span class="token class-name">NumStr</span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span>
</code></pre></div><p>接口继承：</p> <p>如果两个接口之间有相同的属性或方法，可以<code>将公共的属性或方法抽离出来，通过继承来实现复用</code>。</p> <p>例子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐。</span>
<span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>

<span class="token comment">// 更好的方式</span>
<span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Point3D</span> <span class="token keyword">extends</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>

<span class="token comment">// 解释：</span>
<span class="token comment">// 1. 使用 extends（继承）关键字实现了接口 Point3D 继承 Point2D。</span>
<span class="token comment">// 2. 继承后，Point3D 就有了 Point2D 的所有属性和方法（此时，Point3D 同时有 x、y、z 三个属性）。</span>
</code></pre></div><h3 id="元组"><a href="#元组" class="header-anchor">#</a> 元组</h3> <p>场景：在地图中，使用经纬度坐标来标记位置信息。</p> <p>可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> position<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">39.5427</span><span class="token punctuation">,</span><span class="token number">116.2317</span><span class="token punctuation">]</span>
</code></pre></div><p>使用 number[] 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字。</p> <p>更好的方式：<code>元组（Tuple）</code>。</p> <p>元组类型是另一种类型的数组，它<code>确切地知道包含多少个元素，以及特定索引对应的类型</code>。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> position<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">39.5427</span><span class="token punctuation">,</span><span class="token number">116.2317</span><span class="token punctuation">]</span>

<span class="token comment">// 解释：</span>
<span class="token comment">// 1. 元组类型可以确切地标记出有多少个元素，以及每个元素的类型。</span>
<span class="token comment">// 2. 该示例中，元素有两个元素，每个元素的类型都是 number。</span>
</code></pre></div><h3 id="类型推断和断言"><a href="#类型推断和断言" class="header-anchor">#</a> 类型推断和断言</h3> <h4 id="类型推断"><a href="#类型推断" class="header-anchor">#</a> 类型推断</h4> <p>在 TS 中，某些没有明确指出类型的地方，TS 的类型推论机制会帮助提供类型。</p> <p>换句话说：由于类型推论的存在，这些地方，类型注解可以省略不写！</p> <p>发生类型推论的 2 种常见场景：1 声明变量并初始化时 2 决定函数返回值时。</p> <p>例子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">18</span> <span class="token comment">// TS 自动推断出变量 age 为 number 类型</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> num2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2
<span class="token punctuation">}</span>
<span class="token comment">// TS 自动推断出该函数的返回值类型为 number</span>
</code></pre></div><p>推荐：<code>能省略类型注解的地方就省略</code>（偷懒，充分利用TS类型推论的能力，提升开发效率）。</p> <h4 id="类型断言"><a href="#类型断言" class="header-anchor">#</a> 类型断言</h4> <p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。</p> <p>语法：宽泛类型 as 具体类型</p> <p>例子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.itcast.cn<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>link<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">传智教育</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword">const</span> aLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span> <span class="token comment">// aLink此时的类型为 HTMLElement</span>
aLink<span class="token punctuation">.</span>href <span class="token comment">// 此时会报错，没有提示</span>

<span class="token comment">// 把 HTMLElement类型 断言成 HTMLAnchorElement 类型，这样再访问 aLink.href 就可以了</span>
<span class="token keyword">const</span> aLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLAnchorElement 
aLink<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'http://www.itheima.com'</span>

<span class="token comment">// 另一种语法，使用 &lt;&gt; 语法，这种语法形式不常用知道即可：</span>
<span class="token keyword">const</span> aLink <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">HTMLAnchorElement</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">document.getElementById('link')
</span></code></pre></div><p><strong>非空断言（!）</strong></p> <p>作用：<code>断言其操作内容是非 null 且非 undefined</code>，<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html" target="_blank" rel="noopener noreferrer">文档链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（<strong>TS 提供的语法</strong>）。</p> <p>使用场景：某个值的类型包含 null 或 undefined。但是，在使用时我们确定该值一定存在。</p> <p>此时，就可以使用<code>非空断言（!）</code>，<strong>告诉 TS 我很确定此处的值不可能为 null 或 undefined</strong>。</p> <p>这样，TS 就可以去掉类型中的 null 或 undefined 类型，从而在访问对象属性时不会报错。</p> <p>注意：<code>非空断言（!）</code>仅仅是从 TS 类型中去掉 null 或 undefined 类型，从而在访问对象属性时不会报错。</p> <p>但是，<strong>该操作不保证代码运行的正确性</strong>，如果值为 null 或 undefined，在代码运行时还是会报错！</p> <h3 id="字面量类型"><a href="#字面量类型" class="header-anchor">#</a> 字面量类型</h3> <p>某个特定的字符串也可以作为 TS 中的类型。例如：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">'Hello'</span> <span class="token comment">// str1是string类型</span>
<span class="token keyword">const</span> str2 <span class="token operator">=</span> <span class="token string">'Hello'</span> <span class="token comment">// str2类型是 Hello</span>
</code></pre></div><p>除字符串外，任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用。</p> <p>使用模式：<code>字面量类型配合联合类型一起使用</code>。</p> <p>使用场景：<code>用来表示一组明确的可选值列表</code>。</p> <p>比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">changeDirection</span><span class="token punctuation">(</span>direction<span class="token operator">:</span> <span class="token string">'up'</span> <span class="token operator">|</span> <span class="token string">'down'</span> <span class="token operator">|</span> <span class="token string">'left'</span> <span class="token operator">|</span> <span class="token string">'right'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个。</p> <p>优势：相比于 string 类型，使用字面量类型更加精确、严谨。</p> <h3 id="枚举类型"><a href="#枚举类型" class="header-anchor">#</a> 枚举类型</h3> <p>枚举的功能类似于字面量类型+联合类型组合的功能，也可以<code>表示一组明确的可选值</code>。</p> <p>枚举：<code>定义一组命名常量</code>。它描述一个值，该值可以是这些命名常量中的一个。</p> <p>例子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span> Up<span class="token punctuation">,</span> Down<span class="token punctuation">,</span> Left<span class="token punctuation">,</span> Right <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">changeDirection</span><span class="token punctuation">(</span>direction<span class="token operator">:</span> Direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 注意：形参 direction 的类型为枚举 Direction，那么，实参的值就应该是枚举 Direction 成员的任意一个。 访问枚举成员：</span>
<span class="token function">changeDirection</span><span class="token punctuation">(</span>Direction<span class="token punctuation">.</span>up<span class="token punctuation">)</span>
<span class="token comment">//解释：类似于 JS 中的对象，直接通过点（.）语法访问枚举的成员。</span>
</code></pre></div><p>解释：</p> <ol><li><p>使用 <code>enum</code>关键字定义枚举。</p></li> <li><p>约定枚举名称、枚举中的值以大写字母开头。</p></li> <li><p>枚举中的多个值之间通过 ,（逗号）分隔。</p></li> <li><p>定义好枚举后，直接使用枚举名称作为类型注解。</p></li></ol> <h4 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h4> <p><code>枚举成员是有值的</code>，默认为：<code>从 0 开始自增的数值</code>。</p> <p>我们把，枚举成员的值为数字的枚举，称为：<code>数字枚举</code>。</p> <p>当然，也可以给枚举中的成员初始化值。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span>
<span class="token keyword">enum</span> Direction <span class="token punctuation">{</span> Up <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> Down<span class="token punctuation">,</span> Left，Right <span class="token punctuation">}</span>
<span class="token keyword">enum</span> Direction <span class="token punctuation">{</span> Up <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Down <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> Left <span class="token operator">=</span> <span class="token number">8</span>，Right <span class="token operator">=</span> <span class="token number">16</span> <span class="token punctuation">}</span>
</code></pre></div><p>字符串枚举：枚举成员的值是字符串。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span> 
    Up <span class="token operator">=</span> <span class="token string">'Up'</span><span class="token punctuation">,</span> 
    Down <span class="token operator">=</span> <span class="token string">'Down'</span><span class="token punctuation">,</span> 
    Left <span class="token operator">=</span> <span class="token string">'Left'</span>，
    Right <span class="token operator">=</span> <span class="token string">'Right'</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>注意：字符串枚举没有自增长行为，因此，<code>字符串枚举的每个成员必须有初始值</code>。</p> <h4 id="其它"><a href="#其它" class="header-anchor">#</a> 其它</h4> <p>枚举是 TS 为数不多的非 JavaScript 类型级扩展（不仅仅是类型）的特性之一。</p> <p>因为：其他类型仅仅被当做类型，而<code>枚举不仅用作类型，还提供值</code>（枚举成员都是有值的）。</p> <p>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<code>枚举类型会被编译为 JS 代码</code>！</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/enum.3a7f7d5b.png" alt="enum"></p> <p>说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表。</p> <p>一般情况下，<code>推荐使用字面量类型+联合类型组合的方式</code>，因为相比枚举，这种方式更加直观、简洁、高效。</p> <h3 id="👎any-类型"><a href="#👎any-类型" class="header-anchor">#</a> 👎Any 类型</h3> <p>原则：<strong>不推荐使用 any</strong>！这会让 TypeScript 变为 “AnyScript”（失去 TS 类型保护的优势）。</p> <p>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/any.8102cf04.png" alt="any"></p> <p>解释：以上操作都不会有任何类型错误提示，即使可能存在错误！</p> <p>尽可能的避免使用 any 类型，<code>除非临时使用 any</code>来“避免”书写很长、很复杂的类型！</p> <p>其他隐式具有 any 类型的情况：1 声明变量不提供类型也不提供默认值 2 函数参数不加类型。</p> <p>注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型！</p> <h3 id="其它-2"><a href="#其它-2" class="header-anchor">#</a> 其它</h3> <p><strong>typeof</strong></p> <p>众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 打印 string</span>
</code></pre></div><p>实际上，<code>TS 也提供了 typeof 操作符</code>：可以在<strong>类型上下文</strong>中引用变量或属性的类型（类型查询）。</p> <p>使用场景：根据已有变量的值，获取该值的类型，来简化类型书写。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> x：<span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">formatPoint</span><span class="token punctuation">(</span>point<span class="token operator">:</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token function">formatPoint</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">formatPoint</span><span class="token punctuation">(</span>point<span class="token operator">:</span> <span class="token keyword">typeof</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>解释：</p> <ol><li><p>使用 typeof 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同。</p></li> <li><p>typeof 出现在类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文（区别于 JS 代码）。</p></li> <li><p>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）。</p></li></ol> <h2 id="高级类型"><a href="#高级类型" class="header-anchor">#</a> 高级类型</h2> <h3 id="交叉类型"><a href="#交叉类型" class="header-anchor">#</a> 交叉类型</h3> <p>交叉类型（&amp;）：功能类似于接口继承（extends），<em><strong>用于组合多个类型为一个类型</strong></em>（<strong>常用于对象类型</strong>）。</p> <p>比如：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Contact</span> <span class="token punctuation">{</span> phone<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PersonDetail</span> <span class="token operator">=</span> Person <span class="token operator">&amp;</span> Contact
<span class="token keyword">let</span> obj<span class="token operator">:</span> PersonDetail <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    phone<span class="token operator">:</span> <span class="token string">'13811111111'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解释：使用交叉类型后，新的类型 <code>PersonDetail</code> 就<code>同时具备</code>了 Person 和 Contact 的所有属性类型。</p> <p>相当于：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">type</span> <span class="token class-name">PersonDetail</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> phone<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span>
</code></pre></div><p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/overlapping.077b286c.png" alt="overlapping"></p> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p><code>泛型</code>是可以在<code>保证类型安全</code>前提下，让函数等<code>与多种类型一起工作</code>，从而<code>实现复用</code>，常用于：<code>函数</code>、<code>接口</code>、<code>class</code> 中。</p> <p>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token punctuation">}</span>
</code></pre></div><p>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型。</p> <p>为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">id</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token punctuation">}</span>
</code></pre></div><p><strong>泛型</strong>在<strong>保证类型安全</strong>（不丢失类型信息）的同时，可以<strong>让函数等与多种不同的类型一起工作</strong>，灵活可<strong>复用</strong>。</p> <p>实际上，在 C＃和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一。</p> <h3 id="创建泛型函数"><a href="#创建泛型函数" class="header-anchor">#</a> 创建泛型函数</h3> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span><span class="token operator">:</span> Type <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token punctuation">}</span>
</code></pre></div><p>解释：</p> <ol><li><p>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<code>尖括号中添加类型变量</code>，比如此处的 Type。</p></li> <li><p><code>类型变量</code> Type，<code>是一种特殊类型的变量</code>，<code>它处理类型</code>而不是值。</p></li> <li><p>该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）。</p></li> <li><p>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型。</p></li> <li><p>类型变量 Type，可以是任意合法的变量名称。</p></li></ol> <h3 id="调用泛型函数"><a href="#调用泛型函数" class="header-anchor">#</a> 调用泛型函数</h3> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics1.e257d8f0.png" alt="generics1"></p> <p>解释：</p> <ol><li><p>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<code>尖括号中指定具体的类型</code>，比如，此处的 number。</p></li> <li><p>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到。</p></li> <li><p>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number。</p></li></ol> <p>同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string。</p> <p>这样，通过<code>泛型</code>就做到了让 id 函数与多种不同的类型一起工作，<code>实现了复用的同时保证了类型安全</code>。</p> <h3 id="简化调用泛型函数"><a href="#简化调用泛型函数" class="header-anchor">#</a> 简化调用泛型函数</h3> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics2.219b939c.png" alt="generics2"></p> <p>解释：</p> <ol><li><p>在调用泛型函数时，<code>可以省略 &lt;类型&gt; 来简化泛型函数的调用</code>。</p></li> <li><p>此时，TS 内部会采用一种叫做<code>类型参数推断</code>的机制，来根据传入的实参自动推断出类型变量 Type 的类型。</p></li> <li><p>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型。</p></li></ol> <p>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读。</p> <p>说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数。</p> <h3 id="泛型约束"><a href="#泛型约束" class="header-anchor">#</a> 泛型约束</h3> <p>默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性。</p> <p>比如，id('a') 调用函数时获取参数的长度：</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics3.97c39a1b.png" alt="generics3"></p> <p>解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。</p> <p>此时，就需要为泛型<code>添加约束</code>来<strong>收缩类型</strong>（缩窄类型取值范围）。</p> <p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型  2 添加约束。</p> <ol><li><code>指定更加具体的类型</code></li></ol> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics4.08a9ca39.png" alt="generics4"></p> <p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束。</p> <ol start="2"><li><code>添加约束</code></li></ol> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics5.94fee0cf.png" alt="generics5"></p> <p>泛型的类型变量可以有多个，并且<code>类型变量之间还可以约束</code>（比如，第二个类型变量受第一个类型变量约束）。</p> <p>比如，创建一个函数来获取对象中属性的值：</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics6.7d3c66fa.png" alt="generics6"></p> <h3 id="泛型接口"><a href="#泛型接口" class="header-anchor">#</a> 泛型接口</h3> <p>接口也可以配合泛型来使用，以增加其灵活性，增强其复用性。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics7.6bb4a6d9.png" alt="generics7"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics8.eaefbf67.png" alt="generics8"></p> <h3 id="泛型工具类型"><a href="#泛型工具类型" class="header-anchor">#</a> 泛型工具类型</h3> <p>TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作。</p> <p>说明：它们都是<code>基于泛型实现</code>的（泛型适用于多种类型，更加通用），并且是内置的，可以直接在代码中使用。</p> <p>这些工具类型有很多，主要学习以下几个：</p> <ol><li><p><code>Partial&lt;Type&gt;</code></p></li> <li><p><code>Readonly&lt;Type&gt;</code></p></li> <li><p><code>Pick&lt;Type, Keys&gt;</code></p></li> <li><p><code>Record&lt;Keys, Type&gt;</code></p></li></ol> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics10.bd9fc152.png" alt="generics10"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics11.3e2bc01f.png" alt="generics11"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics12.88eb3a71.png" alt="generics12"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/generics13.8f689e73.png" alt="generics13"></p> <h2 id="索引签名类型"><a href="#索引签名类型" class="header-anchor">#</a> <strong>索引签名类型</strong></h2> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/index1.898c7bb0.png" alt="index1"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/index2.a3ef080c.png" alt="index2"></p> <h2 id="映射类型"><a href="#映射类型" class="header-anchor">#</a> 映射类型</h2> <p>基于旧类型创建新类型（对象类型），减少重复、提升开发效率。</p> <p>比如，类型 PropKeys 有 x/y/z，另一个类型 Type1 中也有 x/y/z，并且 Type1 中 x/y/z 的类型相同：</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/map1.10922638.png" alt="map1"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/map2.8d94b3ae.png" alt="map2"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/map3.ec449018.png" alt="map3"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/map4.1898d3d0.png" alt="map4"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/map5.c0636a7e.png" alt="map5"></p> <h2 id="类型声明文件"><a href="#类型声明文件" class="header-anchor">#</a> 类型声明文件</h2> <h3 id="概述-3"><a href="#概述-3" class="header-anchor">#</a> 概述</h3> <p>今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。</p> <p>这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。</p> <p>我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。</p> <p>但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢？<code>类型声明文件</code></p> <p><code>类型声明文件：用来为已存在的 JS 库提供类型信息</code>。</p> <p>这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p> <ol><li><p>TS 的两种文件类型</p></li> <li><p>类型声明文件的使用说明</p></li></ol> <h3 id="ts-中的两种文件类型"><a href="#ts-中的两种文件类型" class="header-anchor">#</a> TS 中的两种文件类型</h3> <p>TS 中有两种文件类型：1 <code>.ts 文件</code> 2 <code>.d.ts 文件</code>。</p> <ul><li>.ts 文件：</li></ul> <ol><li><code>既包含类型信息又包含可执行代码</code>。</li> <li>可以被编译为 .js 文件，然后，执行代码。</li> <li>用途：编写程序代码的地方。</li></ol> <ul><li>.d.ts 文件：</li></ul> <ol><li><p><code>只包含类型信息</code>的类型声明文件。</p></li> <li><p><code>不会生成 .js 文件</code>，仅用于<code>提供类型信息</code>。</p></li> <li><p>用途：为 JS 提供类型信息。</p></li></ol> <p>总结：.ts 是 implementation（代码实现文件）；<strong>.d.ts 是 declaration（类型声明文件）</strong>。</p> <p>如果要为 JS 库提供类型信息，要使用 .d.ts 文件。</p> <h3 id="类型声明文件的使用说明"><a href="#类型声明文件的使用说明" class="header-anchor">#</a> 类型声明文件的使用说明</h3> <p>在使用 TS 开发项目时，<code>类型声明文件的使用</code>包括以下两种方式：</p> <ol><li><p>使用已有的类型声明文件</p></li> <li><p>创建自己的类型声明文件</p></li></ol> <p>学习顺序：<code>先会用</code>（别人的）<code>再会写</code>（自己的）。</p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/declare1.fe51b1fe.png" alt="declare1"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/declare2.2c0d3e25.png" alt="declare2"></p> <p><img src="/vue3-ts-erabbit-client-pc-document/assets/img/declare3.1970de34.png" alt="declare3"></p> <p>创建自己的类型声明文件：1 <code>项目内共享类型</code> 2 <code>为已有 JS 文件提供类型声明</code>。</p> <p>1、项目内共享类型：</p> <p><code>如果多个 .ts 文件</code>中都用到同一个类型，此时可以创建 <code>.d.ts</code> 文件提供该类型，<code>实现类型共享</code>。</p> <p>操作步骤：</p> <ol><li>创建 index.<code>d.ts</code> 类型声明文件。</li> <li>创建需要共享的类型，并<code>使用 export 导出</code>（TS 中的类型也可以使用 import/export 实现模块化功能）。</li> <li>在需要使用共享类型的 .ts 文件中，通过 import 导入即可（.d.ts 后缀导入时，直接省略）。</li></ol> <p>2、为已有 JS 文件提供类型声明：</p> <ol><li><p>在<code>将 JS 项目迁移到 TS 项目</code>时，为了让已有的 .js 文件有类型声明。</p></li> <li><p>成为库作者，创建库给其他人使用。</p></li></ol> <p>注意：<code>类型声明文件的编写与模块化方式相关</code>，不同的模块化方式有不同的写法。但由于历史原因，JS 模块化的发展</p> <p>经历过多种变化（AMD、CommonJS、UMD、ESModule 等），而 TS 支持各种模块化形式的类型声明。这就导致</p> <p>，类型声明文件相关内容又多又杂。</p> <p>演示：基于<code>最新的 ESModule</code>（import/export）来为已有 .js 文件，创建类型声明文件。</p> <p>开发环境准备：使用 webpack 搭建，通过 <code>ts-loader</code> 处理 .ts 文件。</p> <p>说明：TS 项目中也可以使用 .js 文件。</p> <p>说明：在导入 .js 文件时，<code>TS 会自动加载与 .js 同名的 .d.ts 文件</code>，以提供类型声明。</p> <p><code>declare</code> 关键字：<code>用于类型声明</code>，<code>为其他地方</code>（比如，.js 文件）<code>已存在的变量声明类型，而不是创建一个新的变量</code>。</p> <ol><li><p>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的），可以省略 declare 关键字。</p></li> <li><p>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明确指定此处用于类型声明。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/vue3-ts-erabbit-client-pc-document/assets/js/app.37883b6e.js" defer></script><script src="/vue3-ts-erabbit-client-pc-document/assets/js/2.6206effc.js" defer></script><script src="/vue3-ts-erabbit-client-pc-document/assets/js/3.30ca6af5.js" defer></script>
  </body>
</html>